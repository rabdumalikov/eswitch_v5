<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>eswitch_v5: User Manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">eswitch_v5
   </div>
   <div id="projectbrief">This header-only library enhance functionality of Native C++ switch statement</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">User Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tutorial-preface">Preface</a><ul><li class="level2"><a href="#tutorial-installation">Installation</a></li>
<li class="level2"><a href="#tutorial-license">License</a></li>
<li class="level2"><a href="#tutorial-compilers">Supported Compilers</a></li>
</ul>
</li>
<li class="level1"><a href="#tutorial-quick-start">Quick Start</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="tutorial-preface"></a>
Preface</h1>
<hr/>
<p> <b>Eswitch</b> it is header-only library which was written on c++20. This code it is my attempt to <em>enhance</em> <b>switch statement</b> capability with similar syntax.</p>
<h2><a class="anchor" id="tutorial-installation"></a>
Installation</h2>
<hr/>
<p> Since this library is header-only and on top of that whole library was implemented within single file, thus you can get that file from <a href="https://github.com/rabdumalikov/eswitch_v5/tree/main/include/eswitch">eswitch_v5 repository</a> on github. And in order to compile with eswitch_v5, just <code>#include &lt;<a class="el" href="eswitch__v5_8hpp.html" title="implementation ">eswitch_v5.hpp</a>&gt;</code>.</p>
<h2><a class="anchor" id="tutorial-license"></a>
License</h2>
<hr/>
<p> This code is distributed under the Boost Software License, Version 1.0. (See accompanying file <a href="https://github.com/rabdumalikov/eswitch_v5/blob/main/LICENSE.txt">LICENSE.txt</a> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)</p>
<h2><a class="anchor" id="tutorial-compilers"></a>
Supported Compilers</h2>
<hr/>
<p> Should work on all major compilers which support C++20. I personally tested on following:</p>
<ul>
<li>clang++-11 (or later)</li>
<li>g++-10.2 (or later)</li>
<li>Visual Studio 2019 - isn't supported for now, just because not all the features from c++20 were implemented by Microsoft compiler.</li>
</ul>
<h1><a class="anchor" id="tutorial-quick-start"></a>
Quick Start</h1>
<hr/>
<p> <b>eswitch_v5</b> is a library which emulate _C++_ functionality i.e. <b>switch statement</b> and through this emulation I was able to overcome <b>native switch</b> limitations:</p>
<ul>
<li>one parameter per <b>native switch</b></li>
<li>the parameter restricted to only <em>integral</em> types( <b>int</b>, <b>char</b>, <b>enum</b> ... ).</li>
</ul>
<p><b>eswitch_v5</b> supports any number of <em>parameters</em> and almost without restriction on their <em>type</em> as long as the <em>type</em> is <b>comparable</b>( i.e. has <b>operator==**, **operator!=** and so on ). Additionally, my library allow to match for **std::any, std::variant&lt;...&gt;, polymorphic type match</b> and <b>std::regex</b>. Also it allows to withdraw values from those types, of course if match was successful.</p>
<h3>Motivation</h3>
<p>I don't see any good reason why <b>switch statement</b> in <b>C++** is so limited, whereas other statements such as **if, while, for</b> have no such limitations and they allow to compose and test complex condition. Moreover in terms of <em><b>assembler</b></em> output, <b>if</b> and <b>switch</b> statements give the same output, thus the performance also the same. If there isn't any benefits to keep <b>switch statement</b> limited, so why the things the way they are? I also don't think that <b>switch statement</b> is limited because of compatability with <b>C</b>, because syntax of <b>if statement</b> is still compatible with <b>C</b> even though it was extended in <b>C++17</b>, this extention allows to declare variable within <b>if statement</b> like this: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span>( std::smatch mt; std::regex( text, mt, rgx ) ) {...}</div></div><!-- fragment --><p> On top of that the internet is full of questions:</p><ul>
<li><a href="https://stackoverflow.com/questions/650162/why-the-switch-statement-cannot-be-applied-on-strings">Why strings cannot be used in <b>switch statement</b></a>,</li>
<li><a href="https://stackoverflow.com/questions/68578/multiple-cases-in-switch-statement">How to compose complex condition in <b>switch statement</b></a></li>
<li>etc.</li>
</ul>
<p>And there was even the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3627.html">proposal</a> for <b>C++ standard committee</b> to allow to use <em>complex types</em>( like <b>string</b>, <b>complex numbers</b>, etc ) within <b>switch statement</b> and <b>committee</b> <span style="color:green"> <em>agreed</em> </span> about <b>importance of this topic</b>. But somehow the author stopped his work toward this direction.</p>
<p>There is more, compilers such as <b>clang</b> and <b>gcc</b> have non-standard extention for matching <a href="https://gcc.gnu.org/onlinedocs/gcc/Case-Ranges.html"><b>case ranges</b></a>. </p><div class="fragment"><div class="line"><span class="keywordflow">switch</span>( num )                              <span class="keywordflow">switch</span>( ch )</div><div class="line">{                                          {</div><div class="line">    <span class="keywordflow">case</span> 1 ... 5: <span class="keywordflow">break</span>;                       <span class="keywordflow">case</span> <span class="charliteral">&#39;A&#39;</span> ... <span class="charliteral">&#39;Z&#39;</span>: <span class="keywordflow">break</span>;          </div><div class="line">    <span class="keywordflow">case</span> 10 ... 99: <span class="keywordflow">break</span>;                     <span class="keywordflow">case</span> <span class="charliteral">&#39;a&#39;</span> ... <span class="charliteral">&#39;z&#39;</span>: <span class="keywordflow">break</span>;      </div><div class="line">};                                         };</div></div><!-- fragment --><p> The evidence above tell us that people don't like limitations of <b>switch statement</b>, and they're trying to overcome them with different approaches( by implementing <b>non-standard extension</b> or writing <b>proposals</b> or just <b>wondering</b> ).</p>
<p>For modern language like <b>swift</b> it is not an issue, because they have pretty advanced <b>switch statement</b>.</p>
<p>Based on those factors I decided to write my own implementation of <b>enhanced switch</b> or just <b>eswitch</b>. In my implementation I tried to aim all the <b>limitations</b> and leave the syntax of <b>eswitch</b> as close as possible to _native C++_ <b>switch statement</b>. And last but not least, another my priority was the performance of <b>eswitch</b>, which shouldn't differ by much from <b>native switch</b>.</p>
<h3>Conventions used in this document:</h3>
<p>In all code examples, I omit the namespace prefixes for names in the <b>eswitch_v5</b> and <b>std</b> namespaces. Also I'm going to use following name conventions:</p><ul>
<li><b>native switch</b> =&gt; _native C++_ <b>switch statement</b></li>
<li><b>eswitch</b> =&gt; my custom implementation of <b>enhanced switch statement</b></li>
</ul>
<h3>Similarities</h3>
<p>As I have mentioned that I've tried within my implementation to resemble _C++_ <b>switch statement</b> syntax. And I think I was able to achieve this, except the places where I was either limited by language or intentionally tried to avoid certain behavior of <b>switch statement</b> in _C++_ like default <b>fallthrough</b>. Compare:</p>
<div class="fragment"><div class="line"><span class="keywordflow">switch</span>( num )</div><div class="line">{</div><div class="line">    <span class="keywordflow">case</span> 1:  {...} <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> 2:  {...} <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">default</span>: {...} <span class="keywordflow">break</span>;</div><div class="line">};</div></div><!-- fragment --><p>with</p>
<div class="fragment"><div class="line">eswitch( num )</div><div class="line">(</div><div class="line">    Case( 1 ) {...},</div><div class="line">    Case( 2 ) {...},</div><div class="line">    <a class="code" href="group__macroses.html#gaff2b0c246e6111e260e650b0ff4a8eb5">Default</a>   {...}</div><div class="line">);</div></div><!-- fragment --><p> <b>Note That:</b> <em>Native</em> <b>switch statement</b> in <em>C++_ has _explicit</em> <b>break</b> and <em>implicit</em> <b>fallthrough</b> which proven to be error-prone approach. Since developers sometimes forget to use <b>break</b> and because of this their code doesn't work the way it was intended. Thus in my implementation I reversed this concept i.e. <b>eswitch</b> has <em>implicit</em> <b>break</b> and <em>explicit</em> <b>fallthrough</b>. Compare:</p>
<div class="fragment"><div class="line"><span class="keywordflow">switch</span>( num )                    </div><div class="line">{                                </div><div class="line">    <span class="keywordflow">case</span> 1:  {...}           </div><div class="line">    <span class="keywordflow">case</span> 2:  {...} <span class="keywordflow">break</span>;        </div><div class="line">    <span class="keywordflow">default</span>: {...} <span class="keywordflow">break</span>;        </div><div class="line">};                               </div></div><!-- fragment --><p>with</p>
<div class="fragment"><div class="line">eswitch( num )</div><div class="line">(</div><div class="line">    Case( 1 ){...} ^ fallthrough_,</div><div class="line">    Case( 2 ){...},</div><div class="line">    <a class="code" href="group__macroses.html#gaff2b0c246e6111e260e650b0ff4a8eb5">Default</a>  {...}</div><div class="line">);</div></div><!-- fragment --><h3>Keywords</h3>
<table class="doxtable">
<tr>
<th align="center">Name </th><th align="center">Description  </th></tr>
<tr>
<td align="center"><em><b>eswitch</b></em> </td><td align="center"><em>accepts list of input parameters</em> </td></tr>
<tr>
<td align="center"><em><b>Case</b></em> </td><td align="center"><em>accepts <b>condition</b> to check and body next to it will be executed if <b>condition</b> matched</em> </td></tr>
<tr>
<td align="center"><em><b>Default</b></em> </td><td align="center"><em>body next to it will be executed if nothing else matched</em> </td></tr>
<tr>
<td align="center"><em><b>fallthrough_</b></em> </td><td align="center"><em>next body will be executed without checking its <b>condition</b></em> </td></tr>
<tr>
<td align="center"><em><b>any_from</b></em> </td><td align="center"><em>accepts values to choose from</em> </td></tr>
<tr>
<td align="center"><em><b>is&lt;sometype&gt;</b></em> </td><td align="center"><em>used within <b>Case</b> for matching types like <b>std::any</b>, <b>std::variant&lt;...&gt;</b> and <b>polymorphic type match</b></em> </td></tr>
<tr>
<td align="center"><em><b>_r</b></em> </td><td align="center"><em>user defined literal for <b>std::regex</b></em> </td></tr>
</table>
<h3>Syntax</h3>
<div class="fragment"><div class="line">eswitch( __params__ )</div><div class="line">( </div><div class="line">    Case( __conditions__ )( __value__ ) { ... } ^ __options__,</div><div class="line">    Default { ... }</div><div class="line">);</div></div><!-- fragment --><p>Where</p>
<table class="doxtable">
<tr>
<th align="center">Name </th><th align="center">Details  </th></tr>
<tr>
<td align="center"><span style="color:blue">__params__</span> </td><td align="center">list of parameters( i.e. param1, param2, ..., param_n ) </td></tr>
<tr>
<td align="center"><span style="color:blue">__conditions__</span> </td><td align="center">match <b>in order</b>( i.e. _1 == smth1 || _2 == smth2 || ... )<br />
or match via <b>any_from</b>( i.e. _1 == <b>any_from</b>( smth1, smth1, ... )<br />
or match via <b>predicate</b>( i.e. ( pred1, _1 ) &amp;&amp; ( pred2, _2 ) &amp;&amp; ... ) </td></tr>
<tr>
<td align="center"><em><b>Optional:</b></em><br />
<span style="color:blue">__value__</span> </td><td align="center">withdrawn values from: <b>std::any</b>, <b>std::variant&lt;...&gt;</b>,<br />
 <b>polymorphic match</b> or <b>std::regex match</b>. </td></tr>
<tr>
<td align="center"><em><b>Optional:</b></em><br />
<span style="color:blue">__options__</span> </td><td align="center">[<b>left empty</b> =&gt; <em>break</em>] or <br />
 [<b>fallthrough_</b> =&gt; <em>execute body of the following case</em>] or <br />
 [<b>likely_</b> which will be introduced in future] </td></tr>
</table>
<h3>Features</h3>
<ul>
<li><b>implicit break</b> - you don't have to specify it</li>
<li><b>fallthrough</b> - is <em>explicit</em></li>
<li><b>composing condition</b> with: <b>&amp;&amp;</b> , **||** , **==** , <b>!=** , **&gt;</b> , **&lt;** , **&lt;=** , **&gt;=**</li>
<li><b>param matching via indexing and without</b></li>
<li><b>comparison made easy</b></li>
<li><b>match for</b>: <em>std::any, std::variant, std::regex</em></li>
<li><b>match and withdraw value from</b>: <em>std::any, std::variant, std::regex</em></li>
</ul>
<h4>Params referencing via indexes</h4>
<div class="fragment"><div class="line">eswitch( p1, p2 )</div><div class="line">(</div><div class="line">    Case( _1 == <span class="keyword">true</span> &amp;&amp; _2 == <span class="keyword">true</span> ) {...},</div><div class="line">    Case( _2 != <span class="keyword">true</span> || _1 == <span class="keyword">true</span> ) {...}</div><div class="line">);   </div><div class="line"><span class="comment">// i.e.</span></div><div class="line">     <span class="keywordflow">if</span>( p1 == <span class="keyword">true</span> &amp;&amp; p2 == <span class="keyword">true</span> ) {...}</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span>( p1 == <span class="keyword">true</span> || p2 == <span class="keyword">true</span> ) {...}</div></div><!-- fragment --><h4>If indexes aren't provided, then it is assummed that they're sequential</h4>
<div class="fragment"><div class="line">eswitch( p1, p2 )</div><div class="line">(</div><div class="line">    Case( <span class="keyword">true</span>, <span class="keyword">false</span> ) {...}, <span class="comment">// same as &quot;Case( _1 == true &amp;&amp; _2 == false )&quot; </span></div><div class="line">    Case( <span class="keyword">false</span> ){...}</div><div class="line">);</div></div><!-- fragment --><h4>Matching via predicates:(it could be either a lambda or a free function)</h4>
<div class="fragment"><div class="line">eswitch( p1, p2 )</div><div class="line">(</div><div class="line">    Case( ( is_odd, _1 ) &amp;&amp; ( is_odd, _2 ) ) {...},</div><div class="line">    Case( ( is_negative( _1, _2 ) ){...}</div><div class="line">);</div><div class="line"></div><div class="line"><span class="comment">// i.e.</span></div><div class="line">     <span class="keywordflow">if</span>( is_odd( p1 ) &amp;&amp; is_odd( p2) ) {...}</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span>( is_negative( p1, p2 ) ) {...}</div></div><!-- fragment --><h4>Check in range via predicate</h4>
<div class="fragment"><div class="line">eswitch( p1 )</div><div class="line">(</div><div class="line">    Case( _1.in( 1, 10 ) ) {...},</div><div class="line">    Case( _1.within( 11, 20 ) ) {...}</div><div class="line">);</div><div class="line"><span class="comment">// OR</span></div><div class="line">eswitch( p1 )</div><div class="line">(</div><div class="line">    Case( _1 &gt; 1 &amp;&amp; _1 &lt; 10 ) {...},</div><div class="line">    Case( _1 &gt;= 11 &amp;&amp; _1 &lt;= 20 ) ) {...}</div><div class="line">);</div><div class="line"></div><div class="line"><span class="comment">// i.e.</span></div><div class="line">     <span class="keywordflow">if</span>( p1 &gt;  1  &amp;&amp; p1 &lt; 10 )  {...}</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span>( p1 &gt;= 11 &amp;&amp; p1 &lt;= 20 ) {...}</div></div><!-- fragment --><h4>Any_from helper function</h4>
<div class="fragment"><div class="line">eswitch( file_extention )</div><div class="line">(</div><div class="line">    Case( any_from( <span class="stringliteral">&quot;cpp&quot;</span>, <span class="stringliteral">&quot;cc&quot;</span>, <span class="stringliteral">&quot;c++&quot;</span>, <span class="stringliteral">&quot;cxx&quot;</span>, <span class="stringliteral">&quot;C&quot;</span> ) ) {...},</div><div class="line">    Case( any_from( <span class="stringliteral">&quot;h&quot;</span>, <span class="stringliteral">&quot;hpp&quot;</span>, <span class="stringliteral">&quot;hh&quot;</span>, <span class="stringliteral">&quot;h++&quot;</span>, <span class="stringliteral">&quot;hxx&quot;</span>, <span class="stringliteral">&quot;H&quot;</span> ) ) {...},</div><div class="line">    <a class="code" href="group__macroses.html#gaff2b0c246e6111e260e650b0ff4a8eb5">Default</a> {...}</div><div class="line">);</div></div><!-- fragment --><h4>Default case</h4>
<div class="fragment"><div class="line">eswitch( p1 )</div><div class="line">(</div><div class="line">    Case( <span class="keyword">false</span> ) {...},</div><div class="line">    <a class="code" href="group__macroses.html#gaff2b0c246e6111e260e650b0ff4a8eb5">Default</a> {...}</div><div class="line">);</div></div><!-- fragment --><h4>Return value from Case</h4>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> val = eswitch( p1 ) </div><div class="line">(</div><div class="line">    Case( 1 ) { <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div><div class="line">);</div></div><!-- fragment --><h4>Match for std::any or std::variant</h4>
<div class="fragment"><div class="line">eswitch( any_ ) </div><div class="line">(</div><div class="line">    Case( is&lt; int &gt;{} ) {...}, <span class="comment">// will be executed in &#39;std::any&#39; contain &#39;int&#39;</span></div><div class="line">    Case( is&lt; string &gt;{} ) {...} <span class="comment">// will be executed in &#39;std::any&#39; contain &#39;std::string&#39;</span></div><div class="line">);</div></div><!-- fragment --><h4>Match and withdraw value from std::any or std::variant</h4>
<div class="fragment"><div class="line">eswitch( any ) </div><div class="line">(</div><div class="line">    Case( is&lt; int &gt;{} )( <span class="keyword">const</span> <span class="keywordtype">int</span> value ) {...}, <span class="comment">// Note that keyword &#39;auto&#39; isn&#39;t allowed( i.e. code won&#39;t compile )</span></div><div class="line">    Case( is&lt; string &gt;{} )( <span class="keyword">const</span> <span class="keywordtype">string</span> &amp; value ) {...}</div><div class="line">);</div></div><!-- fragment --><h4>Match for polymorphic types</h4>
<div class="fragment"><div class="line">eswitch( base_ptr ) </div><div class="line">(</div><div class="line">    Case( is&lt; circle &gt;{} )( circle * c ) { c-&gt;draw(); },</div><div class="line">    Case( is&lt; square &gt;{} )( square * s ) { s-&gt;draw(); }</div><div class="line">);</div><div class="line"><span class="comment">// OR</span></div><div class="line">eswitch( base_ref ) </div><div class="line">(</div><div class="line">    Case( is&lt; circle &gt;{} )( circle &amp; c ) { c.draw(); },</div><div class="line">    Case( is&lt; square &gt;{} )( square &amp; s ) { s.draw(); }</div><div class="line">);</div></div><!-- fragment --><h4>Match for std::regex</h4>
<div class="fragment"><div class="line">eswitch( text ) </div><div class="line">(</div><div class="line">    Case( R<span class="stringliteral">&quot;(\w*)&quot;_r ) { </span><span class="keywordflow">return</span> <span class="stringliteral">&quot;message&quot;</span>; },</div><div class="line">    Case( R<span class="stringliteral">&quot;(\d*)&quot;_r ) { </span><span class="keywordflow">return</span> <span class="stringliteral">&quot;number&quot;</span>; }</div><div class="line">);</div></div><!-- fragment --><h4>Match and withdraw values from std::regex</h4>
<div class="fragment"><div class="line">eswitch( text ) </div><div class="line">(</div><div class="line">    Case( R<span class="stringliteral">&quot;((\w*))&quot;_r )( vector&lt; string &gt; &amp;&amp; match ){ </span><span class="keywordflow">return</span> match[1]; } </div><div class="line">    Case( R<span class="stringliteral">&quot;((\d*))&quot;_r )( vector&lt; string &gt; &amp;&amp; match ){ </span><span class="keywordflow">return</span> match[1]; } </div><div class="line">);</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
